## Оркестрация микросервисов

Приведена упрощенная реализация процедуры получения охотничьего билета с использованием Camunda BPM.

### Ключевые элементы

В приведенном кейсе участвует несколько бизнес-процессов. Для передачи исполнения между процессами применяются три подхода.

#### External Task

![legend1](img\legend1.png)

**External Task** (вызов микросервиса) названы в примерах по своему топику (триплет **сервис->сущность->операция** в
конкретных процессах или **@операция** в дженериках,см [Микросервис](https://structurizr.kbinform.ru/workspace/2/documentation/Hunt/Microservice%20Archetype)). Когда процесс доходит до этой активность в очередь Camunda отправляется внешняя задача, которую исполняет, подписанный на топик микросервис.

#### Call Activity

![legend2](img\legend2.png)

Call Activity логически схож с внешней задаче, только вызывает не работу микросервиса, а другой процесс Camunda.
Вызываемый процесс может быть конкретным, в котором адресации всех **external task** заданы явно, или дженериком – как минимум одна внешняя задача задана только операцией.

#### Сообщения

![legend3](img\legend3.png)

В ситуации когда надо повлиять на уже запущенный процесс применяются **сообщения**. Эти события *ловятся* процессом на любом этапе исполнения. При помощи сообщений (и событий вообще) можно и запускать процессы, но Call Activity обычно удобнее для таких кейсов.

### Инициирующий процесс - Получение запроса

Процесс **smev-init**

![smev_init](img\smev_init.png)

Первый процесс стартует по расписанию через определенные промежутки времени и первым делом вызывает микросервис ["СМЭВ-контроллер"](https://structurizr.kbinform.ru/workspace/2/documentation/Hunt/SMEV%20Controller) (smev-gate). Мы здесь используем операцию @PUT для сущности **Get** без переменных, поскольку данные для создания нового объекта `smev-gate` получит сам из очереди адаптера СМЭВ (если не найдет, выбросит ошибку и процесс завершится).

Предназначение `smev-gate` не только в том чтобы связаться с адаптером СМЭВ, там происходит адаптация принятого пакета, форматирование его таким образом, чтоб попав в **Camunda**, данными было легко управлять. В результате мы можем осуществить маршрутизацию поступившего запроса средствами BPMN.

В первую очередь происходит распределение по виду сведений (верхнеуровневой госуслуге). Для каждого ВС посредством **Call Activity** вызывается соответствующий процесс-роутер и управление передается ему.

### BPM-gateway - Маршрутизация запроса

Показан процесс **ticket-app-request-manager**, вызванный на предыдущем этапе

![ticket-app-request-manager](img\ticket-app-request-manager.png)

По госуслуге могут приходить запросы разного рода, но всегда есть один **первичный** запрос, который запускает собственно процесс предоставления услуги. Другие **сопутствующие** запросы могут быть дополнениями (тут – сообщение) или отменять первичный запрос.

В данном примере маршрутизация довольно элементарная, однако здесь может быть реализована дополнительная логика.

### Целевой бизнес-процесс

![ticketApp](img\ticketApp.png)

#### Запуск

Как было сказано выше, для триггера может применятся как событие (сообщение, сигнал) так и call activity

#### Транзакция

Первая половина процесса обернута транзакцией, так удобнее откатывать изменения. Транзакция заканчивается, когда последнее одобрение получено.

#### Статусы

Смена статуса сущности  (тут – "Заявление на выдачу охотничьего билета") производится отдельным процессом-дженериком, который запускается сообщениями (выделены синим).

![changeStatus](img\changeStatus.png)

Это универсальный процесс, для всех сущностей системы, которые имеют статус. После смены статуса в системе, эта
информация передается в СМЭВ

#### Отмена процесса

Преждевременное завершение процесса происходит либо в виде отказа по результату проверок, либо по инициативе заявителя.

##### Отказ

Активности, которые могут закончиться ошибкой, выделены красным. Где бы ошибка ни возникла, ловится она на границе
транзакции, перенаправляя выполнение процесса в завершение через последнюю смену статуса

##### Отмена

Если вслед за заявлением приходит запрос на его отмену, то сообщение об этом основной процесс ловит при помощи
событийного подпроцесса. Здесь добавлены компенсации, чтоб продемонстрировать этот функционал (шаблон Сага). В
реальности не все 

### Вспомогательные процессы-коннектор

Процессы, вызываемые **Call Activity**

#### SaveOrGet

![saveOrGet](img\saveOrGet.png)

Логический модуль. Такие небольшие схемы помогают убрать из основных бизнес-процессов технические детали вызова
микросервисов (маппинг, сериализация и т.п.) и шлюзы с диаграммы они усложняют ее восприятие, к тому же обрабатывать
ошибки для управления поток намного быстрее.

На этапе разработки важно оценить какие вспомогательные процессы будут наиболее востребованы в разных процессах (
переиспользуемы). В продуктовом состоянии, моделирование бизнес-процессов верхнего "человеческого" уровня должно быть
доступно к освоению сотрудникам любого уровня.

![](embed:camundaView)

#### PersonCheck

> [!NOTE]
>
> *Скорее демонстрационный, чем к исполнению*

![personCheck](img\personCheck.png)

Основной бизнес-процесс рассмотренный выше, в конце транзакции запускает параллельно несколько однотипных проверок
персональных данных охотника. На множественность вложенного подпроцесса указывает символ **III** . Предполагается, что
эти и аналогичные проверки физ.лиц могут возникать в других процедурах (для единственного кейса такая реализация
избыточна)

Здесь используется в дополнение к BPM-процессу DMN-таблица, включенная в него как задача принятия решений.

![hunterCheck](img\hunterCheck.png)

Таблица содержит перечень сервисов, осуществляющих проверки гражданина, способы их вызвать и указатель как обработать
результат.

Проверка запускается для конкретного сервиса, по первым двум output столбцам формируется запрос, по последним –
вычисляется результат из ответа.